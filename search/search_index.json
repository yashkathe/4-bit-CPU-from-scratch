{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"4 bit CPU ~ from scratch This document contains the design and implementation of a simple 4-bit CPU built entirely using transistors within a simulator environment. The goal of this project is to understand and recreate the fundamental building blocks of a CPU \u2014 including logic gates, arithmetic units, memory, and control logic from the ground up. A 4-bit architecture was chosen to keep the design manageable and easy to debug, while still demonstrating all key concepts such as data flow, instruction execution, and program control. Despite its limited size, a 4-bit CPU is powerful enough to perform arithmetic operations, store data, and run simple programs. This document outlines each component, the thought process behind its construction, and how everything fits together to form a working CPU. logs can be found here Table of Content Digital Logic Basics Transistors PMOS & NMOS Logic Gates AND OR NAND NOR XOR Transistors PMOS and NMOS PMOS and NMOS are two basic types of transistors used to build digital circuits. PMOS - p-type MOSFET PMOS turns ON with 0 because it needs a low signal to let current flow PMOS uses holes as carriers \u2192 needs negative gate (lower voltage) to attract them. NMOS - n-type MOSFET NMOS turns ON with 1 because it needs a high signal to let current flow NMOS uses electrons as carriers \u2192 needs positive gate to attract them. Every transistor have 3 main parts: Emitter Send out charge carriers (eg: electrons) Base Middle Layer that controls the transistor Collector Collects the charge carrier from the emitter Logic Gates Inverter (NOT GATE) Inverter uses a combination of PMOS and NMOS This curcuit is called Complementary-MOS (CMOS) as PMOS & NMOS do opposite things PMOS - pulls up NMOS - pulls down when input is 0 current flows from VDD -> PMOS -> OUTPUT when input is 1 current flows from VDD -> outpu -> NMOS -> GND IN OUT 0 1 1 0 Your browser does not support the video tag. AND A B A AND B 0 0 0 0 1 0 1 0 0 1 1 1 OR A B A OR B 0 0 0 0 1 1 1 0 1 1 1 1 NAND A B A NAND B 0 0 1 0 1 1 1 0 1 1 1 0 NOR A B A NOR B 0 0 1 0 1 0 1 0 0 1 1 0 XOR A B A XOR B 0 0 0 0 1 1 1 0 1 1 1 0","title":"4 bit CPU ~ from scratch"},{"location":"#4-bit-cpu-from-scratch","text":"This document contains the design and implementation of a simple 4-bit CPU built entirely using transistors within a simulator environment. The goal of this project is to understand and recreate the fundamental building blocks of a CPU \u2014 including logic gates, arithmetic units, memory, and control logic from the ground up. A 4-bit architecture was chosen to keep the design manageable and easy to debug, while still demonstrating all key concepts such as data flow, instruction execution, and program control. Despite its limited size, a 4-bit CPU is powerful enough to perform arithmetic operations, store data, and run simple programs. This document outlines each component, the thought process behind its construction, and how everything fits together to form a working CPU. logs can be found here","title":"4 bit CPU ~ from scratch"},{"location":"#table-of-content","text":"Digital Logic Basics Transistors PMOS & NMOS Logic Gates AND OR NAND NOR XOR","title":"Table of Content"},{"location":"#transistors","text":"","title":"Transistors"},{"location":"#pmos-and-nmos","text":"PMOS and NMOS are two basic types of transistors used to build digital circuits. PMOS - p-type MOSFET PMOS turns ON with 0 because it needs a low signal to let current flow PMOS uses holes as carriers \u2192 needs negative gate (lower voltage) to attract them. NMOS - n-type MOSFET NMOS turns ON with 1 because it needs a high signal to let current flow NMOS uses electrons as carriers \u2192 needs positive gate to attract them. Every transistor have 3 main parts: Emitter Send out charge carriers (eg: electrons) Base Middle Layer that controls the transistor Collector Collects the charge carrier from the emitter","title":"PMOS and NMOS"},{"location":"#logic-gates","text":"","title":"Logic Gates"},{"location":"#inverter-not-gate","text":"Inverter uses a combination of PMOS and NMOS This curcuit is called Complementary-MOS (CMOS) as PMOS & NMOS do opposite things PMOS - pulls up NMOS - pulls down when input is 0 current flows from VDD -> PMOS -> OUTPUT when input is 1 current flows from VDD -> outpu -> NMOS -> GND IN OUT 0 1 1 0 Your browser does not support the video tag.","title":"Inverter (NOT GATE)"},{"location":"#and","text":"A B A AND B 0 0 0 0 1 0 1 0 0 1 1 1","title":"AND"},{"location":"#or","text":"A B A OR B 0 0 0 0 1 1 1 0 1 1 1 1","title":"OR"},{"location":"#nand","text":"A B A NAND B 0 0 1 0 1 1 1 0 1 1 1 0","title":"NAND"},{"location":"#nor","text":"A B A NOR B 0 0 1 0 1 0 1 0 0 1 1 0","title":"NOR"},{"location":"#xor","text":"A B A XOR B 0 0 0 0 1 1 1 0 1 1 1 0","title":"XOR"},{"location":"logs/logs/","text":"11052025 asked chat gpt for a roadmap: \ud83e\udde0 Phase 1: Foundations Digital Logic Basics Learn about: Logic gates (AND, OR, NOT, XOR), truth tables, Boolean algebra Build in simulator: All basic gates using only transistors (PMOS, NMOS) Combinational Circuits Learn about: Adders, multiplexers, encoders, decoders Build: Half adder \u2192 full adder 4-bit ripple carry adder Multiplexer (MUX) and Demux Priority encoder / Decoder Sequential Circuits Learn about: Flip-flops (SR, D, JK), latches, clocks Build: D flip-flop using gates \u2192 using transistors Registers (8-bit) Counters (binary, up/down) \u2699\ufe0f Phase 2: Building Blocks of CPU 4. Memory Learn about: SRAM cells, register files, basic RAM Build: 1-bit memory cell 8x8 RAM Instruction Register (IR) ALU (Arithmetic Logic Unit) Include operations: ADD, SUB, AND, OR, NOT, XOR, maybe CMP Build: ALU with opcode control Flag outputs: Zero, Carry, Negative Control Unit Learn about: FSM (Finite State Machines), instruction decoding Build: Microprogrammed or hardwired control logic Instruction set design (start simple: MOV, ADD, JMP) \ud83d\udd17 Phase 3: Integration 7. Buses and Data Path Learn about: Tri-state logic, buses, data flow control Build: Data bus and address bus Control signals for register read/write, ALU operation Program Counter and Branching Implement: Program Counter (PC) Instruction memory fetch JMP/JZ instructions \ud83d\udcbb Phase 4: Final CPU 9. Basic CPU Architecture Combine everything: ALU, registers, control unit, buses, memory Build a simple CPU that can: Fetch \u2192 Decode \u2192 Execute Handle basic assembly-like instructions Sample Programs Write programs in your simple instruction set Run them to test (e.g., add two numbers, loop, conditional jumps)","title":"11052025"},{"location":"logs/logs/#11052025","text":"asked chat gpt for a roadmap: \ud83e\udde0 Phase 1: Foundations Digital Logic Basics Learn about: Logic gates (AND, OR, NOT, XOR), truth tables, Boolean algebra Build in simulator: All basic gates using only transistors (PMOS, NMOS) Combinational Circuits Learn about: Adders, multiplexers, encoders, decoders Build: Half adder \u2192 full adder 4-bit ripple carry adder Multiplexer (MUX) and Demux Priority encoder / Decoder Sequential Circuits Learn about: Flip-flops (SR, D, JK), latches, clocks Build: D flip-flop using gates \u2192 using transistors Registers (8-bit) Counters (binary, up/down) \u2699\ufe0f Phase 2: Building Blocks of CPU 4. Memory Learn about: SRAM cells, register files, basic RAM Build: 1-bit memory cell 8x8 RAM Instruction Register (IR) ALU (Arithmetic Logic Unit) Include operations: ADD, SUB, AND, OR, NOT, XOR, maybe CMP Build: ALU with opcode control Flag outputs: Zero, Carry, Negative Control Unit Learn about: FSM (Finite State Machines), instruction decoding Build: Microprogrammed or hardwired control logic Instruction set design (start simple: MOV, ADD, JMP) \ud83d\udd17 Phase 3: Integration 7. Buses and Data Path Learn about: Tri-state logic, buses, data flow control Build: Data bus and address bus Control signals for register read/write, ALU operation Program Counter and Branching Implement: Program Counter (PC) Instruction memory fetch JMP/JZ instructions \ud83d\udcbb Phase 4: Final CPU 9. Basic CPU Architecture Combine everything: ALU, registers, control unit, buses, memory Build a simple CPU that can: Fetch \u2192 Decode \u2192 Execute Handle basic assembly-like instructions Sample Programs Write programs in your simple instruction set Run them to test (e.g., add two numbers, loop, conditional jumps)","title":"11052025"}]}